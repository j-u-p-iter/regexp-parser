A Binary Grammar example teaches us a lot about how to build Grammar.

Let's look at the next example of a grammar:

```
expression     → literal
               | unary
               | binary
               | grouping ;

literal        → NUMBER | STRING | "true" | "false" | "nil" ;
grouping       → "(" expression ")" ;
unary          → ( "-" | "!" ) expression ;
binary         → expression operator expression ;
operator       → "==" | "!=" | "<" | "<=" | ">" | ">="
               | "+"  | "-"  | "*" | "/" ;
```

Let's say we need to parse the next math expression, using provided above grammar:

```
6 / 3 - 1
```

What parser will do is:

- split the input string of the expression on multiple tokens (tokens for the numbers 6, 3 and 1 and tokens for the operators / and -).
- create AST tree, based on the production rules of the grammar. The parser will try to match the token stream with the production rules. This way the Parser detects which production rule is responsible for which part of the expression and as result for which part of the result AST tree. If there's a situation when the same input string produces two different AST trees (in other words the same set of tokens can be deriviated by different production rules), then the result of the further interpretation of the tree can be incorrect.

The problem with the above input string and the grammar is that we can generate two different trees for the same input string, using the same grammar.

### The first possible tree can be generated by the next "path" of resolving the production rules:

1. Starting at expression, pick binary. We always start fro the starting symbol (expression), so this is the only production rule, that can be chosen for any expression. We choose binary, because Parser can see, that after the 6 symbol, there's an operator, and than it should be binary.
2. For the left-hand expression, pick NUMBER, and use 6. According to the grammar the expression on the left-hand side can be replaced by either literal or binary. And this is where ambiguous grammar comes from. We have two options here. The grammar doesn't allow us to choose only one correct option.
3. For the operator, pick "/".
4. For the right-hand expression, pick binary again. Again, we pick binary here, cause we can see that after the "-" operator goes.
5. In that nested binary expression, pick 3 - 1. There's only one possible way to do it. So here we don't have surprises.

The result tree will look like:

```
{
  type: "Program",
  body: [
    {
      type: "ExpressionStatement",
      expression: [
        {
          type: "BinaryExpression",
          operator: "/",
          // it sits here, cause we chose 6 on the step 2
          left: {
            type: "Literal",
            value: 6,
          },
          right: {
            type: "BinaryExpression",
            operator: "-",
            left: {
              type: "Literal",
              value: 3,
            },
            right: {
              type: "Literal",
              value: 1
            }
          }
        }
      ]
    }
  ]
}
```

This tree is equivalent to the expression:

```
6 / (3 - 1)
```

where the "-" operator has a higher precedence than the "/" operator.

### The second version of the tree can be generated by the next "path" of resolving the production rules:

1. Starting at expression, pick binary. Again, we always start from the starting symbol (expression), so this is the only production rule, that can be chosen for any expression. We choose binary, because Parser can see, that after the 6 symbol, there's an operator, and then it should be binary.
2. For the left-hand expression, pick binary again. On the previous step we chose literal here, now we chose binary. This is where abigous grammar comes from.
3. In that nested binary expression, pick 6 / 3.
4. Back at the outer binary, for the operator, pick "-".
5. For the right-hand expression, pick NUMBER, and use 1.

The result tree will look like:

```
{
  type: "Program",
  body: [
    {
      type: "ExpressionStatement",
      expression: [
        {
          type: "BinaryExpression",
          operator: "-",
          // it sits here, cause we chose 6 on the step 2
          left: {
            type: "BinaryExpression",
            operator: "/",
            left: {
              type: "Literal",
              value: 6,
            },
            right: {
              type: "Literal",
              value: 3,
            },
          },
          right: {
            type: "Literal",
            value: 1
          }
        }
      ]
    }
  ]
}
```

This tree is equivalent to the expression:

```
(6 / 3) - 1
```

The deeper the operator in the tree the higher the precedence of the operator and vice versa. It's because the tree is evaluated from the bottom to the top, from the leaves of the tree, to the root. It means, that at first the deepest BinaryExpression is resolved, after that the BinaryExpression the level above and etc. In other words to evaluate the parent operation we need at first to evaluate the child operation.

And we slowly came to the definition of the ambiguous grammar. Ambiguos grammar is the grammar that makes it possible to deriviate more than one AST tree for the same input string.

Is this a problem? It's a real problem, cause we can just generate incorrect tree and evaluate incorrect result.

To solve the problem with ambiguosity we need to take into an account the precedence and associativity in the grammar.

`Precedence` determines which operator is evaluated first in an expression containing a mixture of different operators. Precedence rules tell us that we evaluate the / before the - in the above example. Operators with higher precedence are evaluated before operators with lower precedence.

`Associativity` determines which operator is evaluated first in a series of the same operator. When an operator is left-associative (think “left-to-right”), operators on the left evaluate before those on the right. Since "-" is left-associative, this expression:

```
5 - 3 - 1
```
is equivalent to:
```
(5 - 3) - 1
```

Assignment, on the other hand, is right-associative. This:

```
a = b = c
```
is equivalent to:
```
a = (b = c)
```

Without well-defined precedence and associativity, an expression that uses multiple operators is ambiguous—it can be parsed into different syntax trees, which could in turn evaluate to different results.

Right now, the grammar stuffs all expression types into a single expression rule. That same rule is used as the non-terminal for operands, which lets the grammar accept any kind of expression as a subexpression, regardless of whether the precedence rules allow it.

So, we need to change the grammar the way it to accept different types of expressions according to the precedence of the operators it includes.

We should define a separate rule for each precedance level.

The result grammar will look like that:

```
expression     → equality ;
equality       → comparison ( ( "!=" | "==" ) comparison )* ;
comparison     → term ( ( ">" | ">=" | "<" | "<=" ) term )* ;
term           → factor ( ( "-" | "+" ) factor )* ;
factor         → unary ( ( "/" | "*" ) unary )* ;
unary          → ( "!" | "-" ) unary
               | primary ;
primary        → NUMBER | STRING | "true" | "false" | "nil"
               | "(" expression ")" ;
```

So, we sorted out the production rules according to the precedence. The highest precedence is at the bottom - it will form the bottom of the AST. The lowest precedence is at the top - and it will be the root of the tree.

The only way how we can match tokens with the provided production rules is by matching them with the static symbols. For the `equality` non-terminal we'll match the token with the comparison operators: "!=" and "==". If there's such type of operator, than we have a deal with the equality and it means that on the left hand side from the operator we have the comparison and on the right hand side from the operator we have either comparison or at least one combination of comparison operator and comparison.

The rule for the equality looks like that:

```
equality → comparison ( ( "!=" | "==" ) comparison )* ;
```

and the code for the equality looks like that:

```
private Equality() {
  let expr = new this.Comparison();

  while (match(BANG_EQUAL, EQUAL_EQUAL)) {
    const operator = previous();
    const right = new this.Comparison();
    
    expr = new this.Binary(expr, operator, right);
  }

  return expr;
}
```

First of all - each grammar rule becomes a method inside this new Parser class, responsible for building the parser.

Each method for parsing a grammar rule produces a syntax tree for that rule and returns it to the caller. When the body of the rule contains a nonterminal— a reference to another rule — we call that other rule’s method. The first call returns the root of the result AST tree, the second call returns the next level after the root, the last call returns the leafs of the AST tree. The last call returns first, because the parent call can't return until the child call returns. The root node of the tree will be returned in the very end and will be containing the whole tree with all child nodes returned before.

So, let's go step by step throug this method:

1. The first comparison nonterminal in the body of the production rule translates to the first call to the this.Comparison in the method. So, nomatter what token after the first one, we always call this.Comparison.
2. After we check if the token matches with the equality operators:

```
while (match(BANG_EQUAL, EQUAL_EQUAL)) { ... }
```

We do it in a loop according to this part of the grammar: `( ( "!=" | "==" ) comparison )*`. In other words we assume that after the second operand there can be the equality operator again and probably after the third one again. So, we do the check until we can't find equality operator after the last consumed operand.

In the while loop we grab the matched operator token so we can track which kind of equality expression we have. After that we call the this.Comparison method again to parse the right hand side operand. At the end we combine the operator and its two operands into a new syntax tree node.

```
while (match(BANG_EQUAL, EQUAL_EQUAL)) {
  const operator = previous();
  const right = comparison();
  expr = new Binary(expr, operator, right);
}
```

If after the second operand there's new equality operator, the new while loop starts and we create new Binary node. 

It's very important to notice, that each new binary node becomes parent node for the binary node created on the previous step and etc. It means, that the first operation from the left will be presented into the first binary node and will be placed at the very bottom of the result AST tree, which means it will have the highest `associativity`, which is absolutely correct for the equality operators (the leftmost equality operator has the highest associativity, the rightmost equality operator has the lowest associativity).

The second thing, that is also very important to notice is that if the parser never encounters an equality operator, then it never enters the loop. In that case, the equality() method effectively calls and returns this.Comparison(). In that way we can say, that the equality production rule was just skipped and we go to the next production rule, which is "comparison". The same happens with any another further production rule. If there's no comparison operator, the comparison production rule will be eventually skipped and we'll switch to the next rule and etc. This is how we can easily can come to the situation, when the expression is resolved as just a number, in case there're no any operators on each step.

According to the provided above grammar the next production rule (from the top) is the production rule for the ComparisonExpression:

```
comparison     → term ( ( ">" | ">=" | "<" | "<=" ) term )* ;
```

The code for the ComparisonExpression is absolutely identical by it's form to the code for the EqualityExpression:

```
private Comparison() {
  let expr = new this.Term();

  while (match(GREATER, GREATER_EQUAL, LESS, LESS_EQUAL)) {
    const operator = previous();
    const right = new this.Term();
    
    expr = new this.Binary(expr, operator, right);
  }

  return expr;
}
```

The Comparison method of the Parser is related to the comparison production rule of the grammar.

According to the grammar there always should be the Term befor the comparison operator. This is why we call the `this.Term` method at first. After that the same way as previously we match the next token with one of the comparison operators. In case we find the operator we go inside the loop and track the operator and the right node and create the BinaryExpression node. This node will be the first node of the comparison production rule and is related to the leftmost comparison expression. As result this node will be located at the bottom of the result AST comparison tree, according to it's associativity. We loop through all comparison operators and create the result comparison expression tree.

And again, if the parser never matches an comparison operator, then it never enters the loop. In that case, the this.Comarison method effectively calls and returns this.Term(). In that way we can say, that the equality production rule was just skipped and we go to the next production rule, which is "term". The same happens with any another further production rule. If there's no additive operator, the term production rule will be eventually skipped and we'll switch to the next rule and etc. This is how we can easily can come to the situation, when the expression is resolved as just a number, in case there're no any operators on each step.

The remaining two binary operator rules (ADDITIVE AND MULTIPLICATIVE operators) follow the same pattern.
 
In the order of the precedence the first operation is the addition and substraction. This operation has lower precedence so it goes above the multiplication and devision in the AST tree.
 
```
private Term() {
  let expr = this.Factor();

  while (match(MINUS, PLUS)) {
    const operator = previous();
    right = this.Factor();
    expr = new this.Binary(expr, operator, right);
  }

  return expr;
}
```

Again, everything is identical to the previous two methods. The only two differences are:
- the operators we match trying to enter the loop;
- the functions we call for the operands.

And for the highest by precedence binary expression the code looks like this:

```
private Factor() {
  let expr = this.Unary();

  while (match(SLASH, STAR)) {
    const operator = previous();
    const right = this.Unary();
    expr = new Binary(expr, operator, right);
  }

  return expr;
}
```

That's all of the binary operators, parsed with the correct precedence and associativity.

The next by precedence according to the grammar is the unary production for the Unary expression.

The code for the unary production looks like:

```
private Unary() {
  if (match(BANG, MINUS)) {
    const operator = previous();
    const right = this.Unary();
    
    return new this.UnaryNode(operator, right);
  }

  return this.Primary();
}
```

Here we can see that if we there's not an appropriate unary operator the unary deriviates eventually to the primary expression. In other words it returns the result of the this.Primary method, which we'll describe later.

If there's unary operator we get the operator itself and call Unary method again, cause there can be at least one more unary operator. So, we recursively call unary until we consume all chain of the unary operators. At the end we call the this.UnaryNode method, which returns the UnaryExpression node. The recursive call creates deeply nested UnaryExpressions tree, which will represent such expressions as `!-2`.

The thing that is very important to point out.

Since the methods for the production rules with higher precedense are called later, they start returning earlier. It means, that the matching of the input string with the tokens starts from the bottom method and goes to the top. The this.Equality method call this.Comparison method, which calls this.Term method and so on and so forth until the this.Primary method is finally called. Only after the this.Primary method called matching starts and the Parser actually first of all matches token with input string on presense of literal values and creates nodes for them. After that it searches for the unary expressions. And again if it could find them - puts them in the appropriate nodes. Couldn't find them - goes further without creation of any nodes. After starts searching for multiplicative binary expression and creates node for them if there're some. All child nodes, found on previous steps will be nest into the multiplicative binary expression. After parser starts searching for additive binary expressions. If there're some - creates appropriate nodes for them and nest previously generated tree into additive binary expression node. And so on and so forth till the very first production rule - which is equality. So, despite the fact that the this.Equality method is called earlier than the this.Factor method, for example, the searching of the multiplicative binary expressions and creation of nodes for them starts earlier than searching and creation of nodes for the equality binary expressions. Internally the Parser has such called counter, which tracks the current position of the cursor. With every new match the cursor is incrementing. Moving from the bottom method call to the top method call, we move from the leftmost  position to the rightmost position incrementally. So there're two types of movement are happening during the parsing process. The first movement is the vertical one, which is happening from the bottom call to the top call (from the bottom node to the top node). The second movement is the horizontal one, which is happening from the leftmost symbol of the input string to the rightmost symbol of the input string.
