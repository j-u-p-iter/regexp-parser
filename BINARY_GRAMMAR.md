A Binary Grammar example teaches us a lot about how to build Grammar.

Let's look at the next example of a grammar:

```
expression     → literal
               | unary
               | binary
               | grouping ;

literal        → NUMBER | STRING | "true" | "false" | "nil" ;
grouping       → "(" expression ")" ;
unary          → ( "-" | "!" ) expression ;
binary         → expression operator expression ;
operator       → "==" | "!=" | "<" | "<=" | ">" | ">="
               | "+"  | "-"  | "*" | "/" ;
```

Let's say we need to parse the next math expression, using provided above grammar:

```
6 / 3 - 1
```

What parser will do is:

- split the input string of the expression on multiple tokens (tokens for the numbers 6, 3 and 1 and tokens for the operators / and -).
- create AST tree, based on the production rules of the grammar. The parser will try to match the token stream with the production rules. This way the Parser detects which production rule is responsible for which part of the expression and as result for which part of the result AST tree. If there's a situation when the same input string produces two different AST trees (in other words the same set of tokens can be deriviated by different production rules), then the result of the further interpretation of the tree can be incorrect.

The problem with the above input string and the grammar is that we can generate two different trees for the same input string, using the same grammar.

### The first possible tree can be generated by the next "path" of resolving the production rules:

1. Starting at expression, pick binary. We always start fro the starting symbol (expression), so this is the only production rule, that can be chosen for any expression. We choose binary, because Parser can see, that after the 6 symbol, there's an operator, and than it should be binary.
2. For the left-hand expression, pick NUMBER, and use 6. According to the grammar the expression on the left-hand side can be replaced by either literal or binary. And this is where ambiguous grammar comes from. We have two options here. The grammar doesn't allow us to choose only one correct option.
3. For the operator, pick "/".
4. For the right-hand expression, pick binary again. Again, we pick binary here, cause we can see that after the "-" operator goes.
5. In that nested binary expression, pick 3 - 1. There's only one possible way to do it. So here we don't have surprises.

The result tree will look like:

```
{
  type: "Program",
  body: [
    {
      type: "ExpressionStatement",
      expression: [
        {
          type: "BinaryExpression",
          operator: "/",
          // it sits here, cause we chose 6 on the step 2
          left: {
            type: "Literal",
            value: 6,
          },
          right: {
            type: "BinaryExpression",
            operator: "-",
            left: {
              type: "Literal",
              value: 3,
            },
            right: {
              type: "Literal",
              value: 1
            }
          }
        }
      ]
    }
  ]
}
```

This tree is equivalent to the expression:

```
6 / (3 - 1)
```

where the "-" operator has a higher precedence than the "/" operator.

### The second version of the tree can be generated by the next "path" of resolving the production rules:

```
1. Starting at expression, pick binary. Again, we always start fro the starting symbol (expression), so this is the only production rule, that can be chosen for any expression. We choose binary, because Parser can see, that after the 6 symbol, there's an operator, and than it should be binary.
2. For the left-hand expression, pick binary again. On the previous step we chose literal here, now we chose binary. This is where abigous grammar comes from.
3. In that nested binary expression, pick 6 / 3.
4. Back at the outer binary, for the operator, pick "-".
5. For the right-hand expression, pick NUMBER, and use 1.
```

The result tree will look like:

```
{
  type: "Program",
  body: [
    {
      type: "ExpressionStatement",
      expression: [
        {
          type: "BinaryExpression",
          operator: "-",
          // it sits here, cause we chose 6 on the step 2
          left: {
            type: "BinaryExpression",
            operator: "/",
            left: {
              type: "Literal",
              value: 6,
            },
            right: {
              type: "Literal",
              value: 3,
            },
          },
          right: {
            type: "Literal",
            value: 1
          }
        }
      ]
    }
  ]
}
```

This tree is equivalent to the expression:

```
(6 / 3) - 1
```

The deeper the operator in the tree the higher the precedence of the operator and vice versa. It's because the tree is evaluated from the bottom to the top, from the leaves of the tree, to the root. It means, that at first the deepest BinaryExpression is resolved, after that the BinaryExpression the level above and etc. In other words to evaluate the parent operation we need at first to evaluate the child operation.

And we slowly came to the definition of the ambiguous grammar. Ambiguos grammar is the grammar that makes it possible to deriviate more than one AST tree for the same input string.

Is this a problem. It's a real problem, cause we can just generate incorrect tree and evaluate incorrect result.

To solve the problem with ambiguosity we need to take into an account the precedence and associativity in the grammar.

`Precedence` determines which operator is evaluated first in an expression containing a mixture of different operators. Precedence rules tell us that we evaluate the / before the - in the above example. Operators with higher precedence are evaluated before operators with lower precedence.

`Associativity` determines which operator is evaluated first in a series of the same operator. When an operator is left-associative (think “left-to-right”), operators on the left evaluate before those on the right. Since - is left-associative, this expression:

```
5 - 3 - 1
```
is equivalent to:
```
(5 - 3) - 1
```

Assignment, on the other hand, is right-associative. This:

```
a = b = c
```
is equivalent to:
```
a = (b = c)
```

Without well-defined precedence and associativity, an expression that uses multiple operators is ambiguous—it can be parsed into different syntax trees, which could in turn evaluate to different results.

Right now, the grammar stuffs all expression types into a single expression rule. That same rule is used as the non-terminal for operands, which lets the grammar accept any kind of expression as a subexpression, regardless of whether the precedence rules allow it.

So, we need to change the grammar the way it to accept different types of expressions according to the precedence of the operators it includes.

We should define a separate rule for each precedance level.

The result grammar will look like that:

```
expression     → equality ;
equality       → comparison ( ( "!=" | "==" ) comparison )* ;
comparison     → term ( ( ">" | ">=" | "<" | "<=" ) term )* ;
term           → factor ( ( "-" | "+" ) factor )* ;
factor         → unary ( ( "/" | "*" ) unary )* ;
unary          → ( "!" | "-" ) unary
               | primary ;
primary        → NUMBER | STRING | "true" | "false" | "nil"
               | "(" expression ")" ;
```

So, we sorted out the production rules according to the precedence. The highest precedence is at the bottom - it will form the bottom of the AST. The lowest precedence is at the top - and it will be the root of the tree.

The only way how we can match tokens with the provided production rules is by matching them with the static symbols. For the `equality` non-terminal we'll match the token with the comparison operators: "!=" and "==". If there's such type of operator, than we have a deal with the equality and it means that on the left hand side from the operator we have the comparison and on the right hand side from the operator we have either comparison or at least one combination of comparison operator and comparison.

The rule for the equality looks like that:

```
equality → comparison ( ( "!=" | "==" ) comparison )* ;
```

and the code for the equality looks like that:

```
private Equality() {
  let expr = new this.Comparison();

  while (match(BANG_EQUAL, EQUAL_EQUAL)) {
    const operator = previous();
    const right = new this.Comparison();
    
    expr = new this.Binary(expr, operator, right);
  }

  return expr;
}
```

First of all - each grammar rule becomes a method inside this new Parser class, responsible for building the parser.

Each method for parsing a grammar rule produces a syntax tree for that rule and returns it to the caller. When the body of the rule contains a nonterminal— a reference to another rule — we call that other rule’s method. The first call returns the root of the result AST tree, the second call returns the next level after the root, the last call returns the leafs of the AST tree. The last call returns first, because the parent call can't return until the child call returns. The root node of the tree will be returned in the very end and will be containing the whole tree with all child nodes returned before.

So, let's go step by step throug this method:

1. The first comparison nonterminal in the body of the production rule translates to the first call to the this.Comparison in the method. So, nomatter what token after the first one, we always call this.Comparison.
2. After we check if the token matches with the equality operators:

```
while (match(BANG_EQUAL, EQUAL_EQUAL)) { ... }
```

We do it in a loop according to this part of the grammar: `( ( "!=" | "==" ) comparison )*`. In other words we assume that after the second operand there can be the equality operator again and probably after the third one again. So, we do the check until we can't find equality operator after the last consumed operand.
