A Binary Grammar example teaches us a lot about how to build Grammar.

Let's look at the next example of a grammar:

```
expression     → literal
               | unary
               | binary
               | grouping ;

literal        → NUMBER | STRING | "true" | "false" | "nil" ;
grouping       → "(" expression ")" ;
unary          → ( "-" | "!" ) expression ;
binary         → expression operator expression ;
operator       → "==" | "!=" | "<" | "<=" | ">" | ">="
               | "+"  | "-"  | "*" | "/" ;
```

Let's say we need to parse the next math expression, using provided above grammar:

```
6 / 3 - 1
```

What parser will do is:

- split the input string of the expression on multiple tokens (tokens for the numbers 6, 3 and 1 and tokens for the operators / and -).
- create AST tree, based on the production rules of the grammar. The parser will try to match the token stream with the production rules. This way the Parser detects which production rule is responsible for which part of the expression and as result for which part of the result AST tree. If there's a situation when the same input string produces two different AST trees (in other words the same set of tokens can be deriviated by different production rules), then the result of the further interpretation of the tree can be incorrect.

The problem with the above input string and the grammar is that we can generate two different trees for the same input string, using the same grammar.

### The first possible tree can be generated by the next "path" of resolving the production rules:

```
1. Starting at expression, pick binary. We always start fro the starting symbol (expression), so this is the only production rule, that can be chosen for any expression. We choose binary, because Parser can see, that after the 6 symbol, there's an operator, and than it should be binary.
2. For the left-hand expression, pick NUMBER, and use 6. According to the grammar the expression on the left-hand side can be replaced by either literal or binary. And this is where ambiguous grammar comes from. We have two options here. The grammar doesn't allow us to choose only one correct option.
3. For the operator, pick "/".
4. For the right-hand expression, pick binary again. Again, we pick binary here, cause we can see that after the "-" operator goes.
5. In that nested binary expression, pick 3 - 1. There's only one possible way to do it. So here we don't have surprises.
```

The result tree will look like:

```
{
  type: "Program",
  body: [
    {
      type: "ExpressionStatement",
      expression: [
        {
          type: "BinaryExpression",
          operator: "/",
          // it sits here, cause we chose 6 on the step 2
          left: {
            type: "Literal",
            value: 6,
          },
          right: {
            type: "BinaryExpression",
            operator: "-",
            left: {
              type: "Literal",
              value: 3,
            },
            right: {
              type: "Literal",
              value: 1
            }
          }
        }
      ]
    }
  ]
}
```

This tree is equivalent to the expression:

```
6 / (3 - 1)
```

where the "-" operator has a higher precedence than the "/" operator.

### The second version of the tree can be generated by the next "path" of resolving the production rules:

```
1. Starting at expression, pick binary.
2. For the left-hand expression, pick binary again.
3. In that nested binary expression, pick 6 / 3.
4. Back at the outer binary, for the operator, pick "-".
5. For the right-hand expression, pick NUMBER, and use 1.
```

The result tree will look like:

```
{
  type: "Program",
  body: [
    {
      type: "ExpressionStatement",
      expression: [
        {
          type: "BinaryExpression",
          operator: "-",
          // it sits here, cause we chose 6 on the step 2
          left: {
            type: "BinaryExpression",
            operator: "/",
            left: {
              type: "Literal",
              value: 6,
            },
            right: {
              type: "Literal",
              value: 3,
            },
          },
          right: {
            type: "Literal",
            value: 1
          }
        }
      ]
    }
  ]
}
```

This tree is equivalent to the expression:

```
(6 / 3) - 1
```

The deeper the operator in the tree the higher the precedence of the operator and vice versa. It's because the tree is evaluated from the bottom to the top, from the leaves of the tree, to the root. It means, that at first the deepest BinaryExpression is resolved, after that the BinaryExpression the level above and etc. In other words to evaluate the parent operation we need at first to evaluate the child operation.

And we slowly came to the definition of the ambiguous grammar. Ambiguos grammar is the grammar that makes it possible to deriviate more than one AST tree for the same input string.
