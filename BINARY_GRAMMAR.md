A Binary Grammar example teaches us a lot about how to build Grammar.

Let's look at the next example of a grammar:

```
expression     → literal
               | unary
               | binary
               | grouping ;

literal        → NUMBER | STRING | "true" | "false" | "nil" ;
grouping       → "(" expression ")" ;
unary          → ( "-" | "!" ) expression ;
binary         → expression operator expression ;
operator       → "==" | "!=" | "<" | "<=" | ">" | ">="
               | "+"  | "-"  | "*" | "/" ;
```

Let's say we need to parse the next math expression, using provided above grammar:

```
6 / 3 - 1
```

What parser will do is:

- split the input string of the expression on multiple tokens (tokens for the numbers 6, 3 and 1 and tokens for the operators / and -).
- create AST tree, based on the production rules of the grammar. The parser will try to match the token stream with the production rules. This way the Parser detects which production rule is responsible for which part of the expression and as result for which part of the result AST tree. If there's a situation when the same input string produces two different AST trees, then the result of the further interpretation of the tree can be incorrect.

The problem with the above input string and the grammar is that we can generate two different trees for the same input string, using the same grammar.

### The first possible tree can be generated by the next "path" of resolving the production rules:

```
1. Starting at expression, pick binary.
2. For the left-hand expression, pick NUMBER, and use 6.
3. For the operator, pick "/".
4. For the right-hand expression, pick binary again.
5. In that nested binary expression, pick 3 - 1
```

The result tree will look like:

```
{
  type: "Program",
  body: [
    {
      type: "ExpressionStatement",
      expression: [
        {
          type: "BinaryExpression",
          operator: "/",
          // it sits here, cause we chose 6 on the step 2
          left: {
            type: "Literal",
            value: 6,
          },
          right: {
            type: "BinaryExpression",
            operator: "-",
            left: {
              type: "Literal",
              value: 3,
            },
            right: {
              type: "Literal",
              value: 1
            }
          }
        }
      ]
    }
  ]
}
```

This tree is equivalent to the expression:

```
6 / (3 - 1)
```

where the "-" operator has a higher precedence than the "/" operator.

### The second version of the tree can be generated by the next "path" of resolving the production rules:

```
1. Starting at expression, pick binary.
2. For the left-hand expression, pick binary again.
3. In that nested binary expression, pick 6 / 3.
4. Back at the outer binary, for the operator, pick "-".
5. For the right-hand expression, pick NUMBER, and use 1.
```

The result tree will look like:

```
{
  type: "Program",
  body: [
    {
      type: "ExpressionStatement",
      expression: [
        {
          type: "BinaryExpression",
          operator: "-",
          // it sits here, cause we chose 6 on the step 2
          left: {
            type: "BinaryExpression",
            operator: "/",
            left: {
              type: "Literal",
              value: 6,
            },
            right: {
              type: "Literal",
              value: 3,
            },
          },
          right: {
            type: "Literal",
            value: 1,
          }
        }
      ]
    }
  ]
}
```

This tree is equivalent to the expression:

```
(6 / 3) - 1
```

The deeper the operator in the tree the higher the precedence of the operator and vice versa. It's because the tree is evaluated from the bottom to the top, from the leaves of the tree, to the root. It means, that at first the deepest BinaryExpression is resolved, after that the BinaryExpression the level above and etc.
